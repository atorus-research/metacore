#' Add a label to a vector
#'
#' @param x Vector to add label to
#' @param label Label to add to vector
#' @return Labeled vector
#' @noRd

add_lab <- function(x, label) {
   if (length(label) == 0) {
      label  <- NULL
   }
   attr(x, "label") <- label
   x
}

#' Add Labels to Dataframe
#' @param .data Dataframe that you want to add labels to
#' @param ... Labeled vector of labels, with the name of the element equal to
#' the name of the column and the element equaling the label, or comma-separated name-value pair
#' @importFrom purrr map2
#' @importFrom tibble tibble as_tibble
#' @importFrom dplyr filter pull
#' @return Dataframe with labels
#' @noRd
add_labs <- function(.data,...) {
   name_list <- c(...)
   df <- tibble(col = names(name_list), lab = name_list)
   .data %>%
      purrr::map2(names(.data), function(x, name) {
         label <- df %>%
            filter(col == name) %>%
            pull(lab) %>%
            unname()
         if(length(label) > 0) {
            add_lab(x, label)
         } else {
            x
         }
      }) %>%
      as_tibble()
}


#' Column Validation Function
#'
#' @param .data the dataframe to check the column for
#' @param col the column to test
#' @param func the function to use to assert column structure
#' @param any_na_acceptable boolean, testing if the column can have missing
#' @param nm name of column to check (for warning and error clarification)
#'
check_structure <- function(.data, col, func, any_na_acceptable, nm) {

   column <- as_string(col)
   vec <- .data %>% pull(!!col)
   warning_string <- NULL
   error_message <- NULL

   if(any(is.na(vec)) & !any_na_acceptable) {
      error_message <- str_glue("`{column}` from the `{nm}` table contains missing values. Actual values are needed.")
   } else if (all(is.na(vec))){
      warning_string <- str_glue("`{column}` from the `{nm}` table only contains missing values.")
   } else {

      failures <-  vec %>%
         discard(~do.call(func, list(.))) %>%
         unique()

      all_fails <- paste(failures)

      if (length(failures) > 0 ) {

         if (is.primitive(func)) {

            assertion_func <- prim_name(func)
            warning_string <- str_glue("{nm}${column} fails {assertion_func} check")

         } else {
            cli_warn(c(
               "The following {qty(all_fails)} word{?s} in {nm}${column} {qty(all_fails)} {?is/are} not allowed:",
               "i" = ansi_collapse(all_fails, last = ", ")
            ), call. = FALSE)
         }
      }
   }

   list(warning = warning_string, error = error_message)
}

#' Check Words in Column
#'
#' @param ... permissible words in the column
#' @param col the column to check for specific words
check_words <- function(..., col) {
   accepted_words <- unlist(c(...))
   expr <- expr(function(col) col %in% !!accepted_words)
   make_function(body = expr, env = parent.frame())()
}

make_function <- function(args = pairlist(), body, env = parent.frame())  {
   eval(call("function", args, body), env)
}


#' Get path to metacore example
#'
#' metacore comes bundled with a number of sample files in its `inst/extdata`
#' directory. This function make them easy to access. When testing or writing
#' examples in other packages, it is best to use the 'pilot_ADaM.rda' example as
#' it loads fastest.
#' @param file Name of file. If `NULL`, the example files will be listed.
#' @export
#' @examples
#' metacore_example()
#' metacore_example("mock_spec.xlsx")
metacore_example <- function(file = NULL) {
   if (is.null(file)) {
      dir(system.file("extdata", package = "metacore"))
   } else {
      system.file("extdata", file, package = "metacore", mustWork = TRUE)
   }
}

#' Evaluate an expression with controlled verbosity
#'
#' This function evaluates an R expression while providing fine-grained control
#' over how messages and warnings generated by the expression are handled.
#' It allows you to suppress messages, suppress warnings, or suppress both using
#' the `verbose` parameter.
#'
#' @param expr The R expression to be evaluated. This expression is passed
#'   unevaluated and will be evaluated within the `parent.frame()`.
#' @param quiet A logical value. If `TRUE`, all messages and warnings
#'   generated by `expr` will be suppressed, overriding the `verbose` setting.
#'   Defaults to `FALSE`.
#' @param verbose A character string specifying the desired verbosity level if
#'   `quiet` is `FALSE`.
#'   Must be one of:
#'   \describe{
#'     \item{"message"}{ (default) Messages and warnings are handled normally.}
#'     \item{"warn"}{Messages are suppressed, but warnings are allowed.}
#'     \item{"silent"}{Both messages and warnings are suppressed (equivalent
#'       to `quiet = TRUE`).}
#'   }
#'   This parameter is validated internally by `validate_verbose()`.
#' @return The result of evaluating `expr`.
#' @section Details:
#' The `quiet` parameter takes precedence over `verbose`. If `quiet = TRUE`,
#' both messages and warnings are suppressed regardless of the `verbose` setting.
#' If `quiet = FALSE`, the behavior is determined by `verbose`.
#'
#' This function uses `withCallingHandlers` and `invokeRestart` to selectively
#' muffle messages and warnings without changing global options.
#'
#' @examples
#' # Example: Suppress messages but allow warnings
#' with_verbosity({
#'   message("This message will be suppressed.")
#'   warning("This warning will be shown!")
#'   1 + 1
#' }, verbose = "warn")
#'
#' # Example: Suppress everything (equivalent to quiet = TRUE)
#' with_verbosity({
#'   message("This message will be suppressed.")
#'   warning("This warning will also be suppressed.")
#'   2 + 2
#' }, verbose = "silent")
#'
#' # Example: Default behavior (messages and warnings shown)
#' with_verbosity({
#'   message("This message will be shown.")
#'   warning("This warning will also be shown.")
#'   3 + 3
#' })
#'
#' Example: Display messages and collapse warnings into a single message
#' with_verbosity({
#'   message("This message will be shown.")
#'   warning("This warning will be collapsed")
#'   warning("This warning will also be collapsed")
#'   4 + 4
#' }, verbose = "collapse")
#'
#' # Example: Using quiet = TRUE
#' with_verbosity({
#'   message("This message is suppressed")
#'   warning("This warning is also suppressed")
#'   5 + 5
#' }, quiet = TRUE)
#' @noRd
with_verbosity <- function(expr, quiet = FALSE, verbose = "message") {
   expr <- substitute(expr)
   verbose <- validate_verbose(verbose)

   if (quiet | verbose == "silent") {
      return(withCallingHandlers(
         eval(expr, parent.frame()),
         message = function(m) invokeRestart("muffleMessage"),
         warning = function(w) invokeRestart("muffleWarning")
      ))

   } else if (verbose == "warn") {
      return(withCallingHandlers(
         eval(expr, parent.frame()),
         message = function(m) invokeRestart("muffleMessage")
      ))

   } else if (verbose == "collapse") {
      warning_count <- 0
      result <- withCallingHandlers(
         eval(expr, parent.frame()),
         warning = function(w) {
            warning_count <<- warning_count + 1
            invokeRestart("muffleWarning")
         }
      )
      if (warning_count > 0) {
         cli_inform(c("i" = cli::col_red(
"Operation performed with {warning_count} suppressed warning{?s}. Set {.arg verbose = \"warn\"} to show.")))
      }
      return(result)

   } else if (verbose == "message") {
      return(
         eval(expr, envir = parent.frame())
      )
   }
}

#' Validate verbose parameter
#'
#' Internal function to validate the `verbose` parameter ensuring user has supplied
#' one of the permitted values: "message", "warn", or "silent". Throws an error
#' if the parameter is invalid.
#'
#' @param verbose Verbosity level to validate. Expected a character string of
#' one of: "message", "warn", "silent".
#' @param arg The name of the argument being validated, used for error messages.
#'   Defaults to `rlang::caller_arg(verbose)`.
#' @param call The call environment from which the validation originated, used
#'   for error messages. Defaults to `rlang::caller_env()`.
#' @return The validated and potentially matched `verbose` string (e.g., if
#'   `verbose = "mess"` is passed, it returns `"message"`). If validation fails,
#'   an error is thrown.
#' @keywords internal validation
#' @noRd
validate_verbose <- function(verbose, arg = rlang::caller_arg(verbose), call = rlang::caller_env()) {
   choices <- c("message", "warn", "collapse", "silent")
   tryCatch(
      match.arg(verbose, choices),
      error = function(e) {
         cli_abort(c(
            "x" = "{.arg {arg}} should be one of: {cli::ansi_collapse(choices, last = ', ')}"
         ), call = call)
      }
   )
}
